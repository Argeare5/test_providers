/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace CrosschainUtils {
  export type PayloadStruct = {
    chain: PromiseOrValue<BigNumberish>;
    accessLevel: PromiseOrValue<BigNumberish>;
    mandateProvider: PromiseOrValue<string>;
    payloadId: PromiseOrValue<BigNumberish>;
    __RESERVED: PromiseOrValue<BigNumberish>;
  };

  export type PayloadStructOutput = [number, number, string, number, number] & {
    chain: number;
    accessLevel: number;
    mandateProvider: string;
    payloadId: number;
    __RESERVED: number;
  };
}

export declare namespace IGovernanceCore {
  export type ProposalStruct = {
    votingChain: PromiseOrValue<BigNumberish>;
    votingDuration: PromiseOrValue<BigNumberish>;
    creationTime: PromiseOrValue<BigNumberish>;
    ____RESERVED: PromiseOrValue<BigNumberish>;
    snapshotBlockHash: PromiseOrValue<BytesLike>;
    accessLevel: PromiseOrValue<BigNumberish>;
    state: PromiseOrValue<BigNumberish>;
    creator: PromiseOrValue<string>;
    payloads: CrosschainUtils.PayloadStruct[];
    queuingTime: PromiseOrValue<BigNumberish>;
    votingPortal: PromiseOrValue<string>;
    ipfsHash: PromiseOrValue<BytesLike>;
    forVotes: PromiseOrValue<BigNumberish>;
    againstVotes: PromiseOrValue<BigNumberish>;
  };

  export type ProposalStructOutput = [
    number,
    number,
    number,
    BigNumber,
    string,
    number,
    number,
    string,
    CrosschainUtils.PayloadStructOutput[],
    number,
    string,
    string,
    BigNumber,
    BigNumber
  ] & {
    votingChain: number;
    votingDuration: number;
    creationTime: number;
    ____RESERVED: BigNumber;
    snapshotBlockHash: string;
    accessLevel: number;
    state: number;
    creator: string;
    payloads: CrosschainUtils.PayloadStructOutput[];
    queuingTime: number;
    votingPortal: string;
    ipfsHash: string;
    forVotes: BigNumber;
    againstVotes: BigNumber;
  };

  export type VotingConfigStruct = {
    isActive: PromiseOrValue<boolean>;
    votingDuration: PromiseOrValue<BigNumberish>;
    quorum: PromiseOrValue<BigNumberish>;
    differential: PromiseOrValue<BigNumberish>;
    minPropositionPower: PromiseOrValue<BigNumberish>;
  };

  export type VotingConfigStructOutput = [
    boolean,
    number,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    isActive: boolean;
    votingDuration: number;
    quorum: BigNumber;
    differential: BigNumber;
    minPropositionPower: BigNumber;
  };

  export type SetVotingConfigInputStruct = {
    accessLevel: PromiseOrValue<BigNumberish>;
    isActive: PromiseOrValue<boolean>;
    votingDuration: PromiseOrValue<BigNumberish>;
    quorum: PromiseOrValue<BigNumberish>;
    differential: PromiseOrValue<BigNumberish>;
    minPropositionPower: PromiseOrValue<BigNumberish>;
  };

  export type SetVotingConfigInputStructOutput = [
    number,
    boolean,
    number,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    accessLevel: number;
    isActive: boolean;
    votingDuration: number;
    quorum: BigNumber;
    differential: BigNumber;
    minPropositionPower: BigNumber;
  };
}

export interface IGovernanceCoreInterface extends utils.Interface {
  functions: {
    "COOLDOWN_PERIOD()": FunctionFragment;
    "NAME()": FunctionFragment;
    "PRECISION_DIVIDER()": FunctionFragment;
    "PROPOSAL_EXPIRATION_TIME()": FunctionFragment;
    "cancel(uint256)": FunctionFragment;
    "create((uint8,uint8,address,uint40,uint40)[],uint8,address,bytes32)": FunctionFragment;
    "execute(uint256)": FunctionFragment;
    "getProposal(uint256)": FunctionFragment;
    "getVotingConfig(uint8)": FunctionFragment;
    "proposalsCount()": FunctionFragment;
    "setVotingConfigs((uint8,bool,uint24,uint256,uint256,uint256)[])": FunctionFragment;
    "setVotingStrategy(address)": FunctionFragment;
    "submitResults(uint256,uint256,uint256)": FunctionFragment;
    "votingStrategy()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "COOLDOWN_PERIOD"
      | "NAME"
      | "PRECISION_DIVIDER"
      | "PROPOSAL_EXPIRATION_TIME"
      | "cancel"
      | "create"
      | "execute"
      | "getProposal"
      | "getVotingConfig"
      | "proposalsCount"
      | "setVotingConfigs"
      | "setVotingStrategy"
      | "submitResults"
      | "votingStrategy"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "COOLDOWN_PERIOD",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "NAME", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "PRECISION_DIVIDER",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PROPOSAL_EXPIRATION_TIME",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "cancel",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "create",
    values: [
      CrosschainUtils.PayloadStruct[],
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "execute",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getProposal",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getVotingConfig",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "proposalsCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setVotingConfigs",
    values: [IGovernanceCore.SetVotingConfigInputStruct[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setVotingStrategy",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "submitResults",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "votingStrategy",
    values?: undefined
  ): string;

  decodeFunctionResult(
    functionFragment: "COOLDOWN_PERIOD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "NAME", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "PRECISION_DIVIDER",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PROPOSAL_EXPIRATION_TIME",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "cancel", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "create", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "execute", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getVotingConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposalsCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setVotingConfigs",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setVotingStrategy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitResults",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "votingStrategy",
    data: BytesLike
  ): Result;

  events: {
    "ApprovedPayloadsRegistryUpdated(address,address)": EventFragment;
    "ProposalCanceled(uint256)": EventFragment;
    "ProposalCreated(uint256,address,uint8,uint24,bytes32,bytes32)": EventFragment;
    "ProposalExecuted(uint256)": EventFragment;
    "ProposalFailed(uint256,uint256,uint256)": EventFragment;
    "ProposalQueued(uint256,uint256,uint256)": EventFragment;
    "VotingConfigUpdated(uint8,bool,uint24,uint256,uint256,uint256)": EventFragment;
    "VotingStrategyUpdated(address,address)": EventFragment;
  };

  getEvent(
    nameOrSignatureOrTopic: "ApprovedPayloadsRegistryUpdated"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalCanceled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalFailed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalQueued"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VotingConfigUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "VotingStrategyUpdated"): EventFragment;
}

export interface ApprovedPayloadsRegistryUpdatedEventObject {
  oldApprovedPayloadsRegistry: string;
  newApprovedPayloadsRegistry: string;
}
export type ApprovedPayloadsRegistryUpdatedEvent = TypedEvent<
  [string, string],
  ApprovedPayloadsRegistryUpdatedEventObject
>;

export type ApprovedPayloadsRegistryUpdatedEventFilter =
  TypedEventFilter<ApprovedPayloadsRegistryUpdatedEvent>;

export interface ProposalCanceledEventObject {
  proposalId: BigNumber;
}
export type ProposalCanceledEvent = TypedEvent<
  [BigNumber],
  ProposalCanceledEventObject
>;

export type ProposalCanceledEventFilter =
  TypedEventFilter<ProposalCanceledEvent>;

export interface ProposalCreatedEventObject {
  proposalId: BigNumber;
  creator: string;
  accessLevel: number;
  votingDuration: number;
  snapshotBlockHash: string;
  ipfsHash: string;
}
export type ProposalCreatedEvent = TypedEvent<
  [BigNumber, string, number, number, string, string],
  ProposalCreatedEventObject
>;

export type ProposalCreatedEventFilter = TypedEventFilter<ProposalCreatedEvent>;

export interface ProposalExecutedEventObject {
  proposalId: BigNumber;
}
export type ProposalExecutedEvent = TypedEvent<
  [BigNumber],
  ProposalExecutedEventObject
>;

export type ProposalExecutedEventFilter =
  TypedEventFilter<ProposalExecutedEvent>;

export interface ProposalFailedEventObject {
  proposalId: BigNumber;
  votesFor: BigNumber;
  votesAgainst: BigNumber;
}
export type ProposalFailedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  ProposalFailedEventObject
>;

export type ProposalFailedEventFilter = TypedEventFilter<ProposalFailedEvent>;

export interface ProposalQueuedEventObject {
  proposalId: BigNumber;
  votesFor: BigNumber;
  votesAgainst: BigNumber;
}
export type ProposalQueuedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber],
  ProposalQueuedEventObject
>;

export type ProposalQueuedEventFilter = TypedEventFilter<ProposalQueuedEvent>;

export interface VotingConfigUpdatedEventObject {
  accessLevel: number;
  isActive: boolean;
  votingDuration: number;
  quorum: BigNumber;
  differential: BigNumber;
  minPropositionPower: BigNumber;
}
export type VotingConfigUpdatedEvent = TypedEvent<
  [number, boolean, number, BigNumber, BigNumber, BigNumber],
  VotingConfigUpdatedEventObject
>;

export type VotingConfigUpdatedEventFilter =
  TypedEventFilter<VotingConfigUpdatedEvent>;

export interface VotingStrategyUpdatedEventObject {
  oldVotingStrategy: string;
  newVotingStrategy: string;
}
export type VotingStrategyUpdatedEvent = TypedEvent<
  [string, string],
  VotingStrategyUpdatedEventObject
>;

export type VotingStrategyUpdatedEventFilter =
  TypedEventFilter<VotingStrategyUpdatedEvent>;

export interface IGovernanceCore extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IGovernanceCoreInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    COOLDOWN_PERIOD(overrides?: CallOverrides): Promise<[BigNumber]>;

    NAME(overrides?: CallOverrides): Promise<[string]>;

    PRECISION_DIVIDER(overrides?: CallOverrides): Promise<[BigNumber]>;

    PROPOSAL_EXPIRATION_TIME(overrides?: CallOverrides): Promise<[BigNumber]>;

    cancel(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    create(
      payloads: CrosschainUtils.PayloadStruct[],
      accessLevel: PromiseOrValue<BigNumberish>,
      votingPortal: PromiseOrValue<string>,
      ipfsHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    execute(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[IGovernanceCore.ProposalStructOutput]>;

    getVotingConfig(
      accessLevel: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[IGovernanceCore.VotingConfigStructOutput]>;

    proposalsCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    setVotingConfigs(
      votingConfigs: IGovernanceCore.SetVotingConfigInputStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setVotingStrategy(
      newVotingStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    submitResults(
      proposalId: PromiseOrValue<BigNumberish>,
      forVotes: PromiseOrValue<BigNumberish>,
      againstVotes: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    votingStrategy(overrides?: CallOverrides): Promise<[string]>;
  };

  COOLDOWN_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

  NAME(overrides?: CallOverrides): Promise<string>;

  PRECISION_DIVIDER(overrides?: CallOverrides): Promise<BigNumber>;

  PROPOSAL_EXPIRATION_TIME(overrides?: CallOverrides): Promise<BigNumber>;

  cancel(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  create(
    payloads: CrosschainUtils.PayloadStruct[],
    accessLevel: PromiseOrValue<BigNumberish>,
    votingPortal: PromiseOrValue<string>,
    ipfsHash: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  execute(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getProposal(
    proposalId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<IGovernanceCore.ProposalStructOutput>;

  getVotingConfig(
    accessLevel: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<IGovernanceCore.VotingConfigStructOutput>;

  proposalsCount(overrides?: CallOverrides): Promise<BigNumber>;

  setVotingConfigs(
    votingConfigs: IGovernanceCore.SetVotingConfigInputStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setVotingStrategy(
    newVotingStrategy: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  submitResults(
    proposalId: PromiseOrValue<BigNumberish>,
    forVotes: PromiseOrValue<BigNumberish>,
    againstVotes: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  votingStrategy(overrides?: CallOverrides): Promise<string>;

  callStatic: {
    COOLDOWN_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    NAME(overrides?: CallOverrides): Promise<string>;

    PRECISION_DIVIDER(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_EXPIRATION_TIME(overrides?: CallOverrides): Promise<BigNumber>;

    cancel(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    create(
      payloads: CrosschainUtils.PayloadStruct[],
      accessLevel: PromiseOrValue<BigNumberish>,
      votingPortal: PromiseOrValue<string>,
      ipfsHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    execute(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<IGovernanceCore.ProposalStructOutput>;

    getVotingConfig(
      accessLevel: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<IGovernanceCore.VotingConfigStructOutput>;

    proposalsCount(overrides?: CallOverrides): Promise<BigNumber>;

    setVotingConfigs(
      votingConfigs: IGovernanceCore.SetVotingConfigInputStruct[],
      overrides?: CallOverrides
    ): Promise<void>;

    setVotingStrategy(
      newVotingStrategy: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    submitResults(
      proposalId: PromiseOrValue<BigNumberish>,
      forVotes: PromiseOrValue<BigNumberish>,
      againstVotes: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    votingStrategy(overrides?: CallOverrides): Promise<string>;
  };

  filters: {
    "ApprovedPayloadsRegistryUpdated(address,address)"(
      oldApprovedPayloadsRegistry?: null,
      newApprovedPayloadsRegistry?: null
    ): ApprovedPayloadsRegistryUpdatedEventFilter;
    ApprovedPayloadsRegistryUpdated(
      oldApprovedPayloadsRegistry?: null,
      newApprovedPayloadsRegistry?: null
    ): ApprovedPayloadsRegistryUpdatedEventFilter;

    "ProposalCanceled(uint256)"(
      proposalId?: PromiseOrValue<BigNumberish> | null
    ): ProposalCanceledEventFilter;
    ProposalCanceled(
      proposalId?: PromiseOrValue<BigNumberish> | null
    ): ProposalCanceledEventFilter;

    "ProposalCreated(uint256,address,uint8,uint24,bytes32,bytes32)"(
      proposalId?: PromiseOrValue<BigNumberish> | null,
      creator?: PromiseOrValue<string> | null,
      accessLevel?: PromiseOrValue<BigNumberish> | null,
      votingDuration?: null,
      snapshotBlockHash?: null,
      ipfsHash?: null
    ): ProposalCreatedEventFilter;
    ProposalCreated(
      proposalId?: PromiseOrValue<BigNumberish> | null,
      creator?: PromiseOrValue<string> | null,
      accessLevel?: PromiseOrValue<BigNumberish> | null,
      votingDuration?: null,
      snapshotBlockHash?: null,
      ipfsHash?: null
    ): ProposalCreatedEventFilter;

    "ProposalExecuted(uint256)"(
      proposalId?: PromiseOrValue<BigNumberish> | null
    ): ProposalExecutedEventFilter;
    ProposalExecuted(
      proposalId?: PromiseOrValue<BigNumberish> | null
    ): ProposalExecutedEventFilter;

    "ProposalFailed(uint256,uint256,uint256)"(
      proposalId?: PromiseOrValue<BigNumberish> | null,
      votesFor?: null,
      votesAgainst?: null
    ): ProposalFailedEventFilter;
    ProposalFailed(
      proposalId?: PromiseOrValue<BigNumberish> | null,
      votesFor?: null,
      votesAgainst?: null
    ): ProposalFailedEventFilter;

    "ProposalQueued(uint256,uint256,uint256)"(
      proposalId?: PromiseOrValue<BigNumberish> | null,
      votesFor?: null,
      votesAgainst?: null
    ): ProposalQueuedEventFilter;
    ProposalQueued(
      proposalId?: PromiseOrValue<BigNumberish> | null,
      votesFor?: null,
      votesAgainst?: null
    ): ProposalQueuedEventFilter;

    "VotingConfigUpdated(uint8,bool,uint24,uint256,uint256,uint256)"(
      accessLevel?: PromiseOrValue<BigNumberish> | null,
      isActive?: PromiseOrValue<boolean> | null,
      votingDuration?: null,
      quorum?: null,
      differential?: null,
      minPropositionPower?: null
    ): VotingConfigUpdatedEventFilter;
    VotingConfigUpdated(
      accessLevel?: PromiseOrValue<BigNumberish> | null,
      isActive?: PromiseOrValue<boolean> | null,
      votingDuration?: null,
      quorum?: null,
      differential?: null,
      minPropositionPower?: null
    ): VotingConfigUpdatedEventFilter;

    "VotingStrategyUpdated(address,address)"(
      oldVotingStrategy?: null,
      newVotingStrategy?: null
    ): VotingStrategyUpdatedEventFilter;
    VotingStrategyUpdated(
      oldVotingStrategy?: null,
      newVotingStrategy?: null
    ): VotingStrategyUpdatedEventFilter;
  };

  estimateGas: {
    COOLDOWN_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    NAME(overrides?: CallOverrides): Promise<BigNumber>;

    PRECISION_DIVIDER(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_EXPIRATION_TIME(overrides?: CallOverrides): Promise<BigNumber>;

    cancel(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    create(
      payloads: CrosschainUtils.PayloadStruct[],
      accessLevel: PromiseOrValue<BigNumberish>,
      votingPortal: PromiseOrValue<string>,
      ipfsHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    execute(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getVotingConfig(
      accessLevel: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    proposalsCount(overrides?: CallOverrides): Promise<BigNumber>;

    setVotingConfigs(
      votingConfigs: IGovernanceCore.SetVotingConfigInputStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setVotingStrategy(
      newVotingStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    submitResults(
      proposalId: PromiseOrValue<BigNumberish>,
      forVotes: PromiseOrValue<BigNumberish>,
      againstVotes: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    votingStrategy(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    COOLDOWN_PERIOD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NAME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PRECISION_DIVIDER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PROPOSAL_EXPIRATION_TIME(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cancel(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    create(
      payloads: CrosschainUtils.PayloadStruct[],
      accessLevel: PromiseOrValue<BigNumberish>,
      votingPortal: PromiseOrValue<string>,
      ipfsHash: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    execute(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getProposal(
      proposalId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getVotingConfig(
      accessLevel: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    proposalsCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setVotingConfigs(
      votingConfigs: IGovernanceCore.SetVotingConfigInputStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setVotingStrategy(
      newVotingStrategy: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    submitResults(
      proposalId: PromiseOrValue<BigNumberish>,
      forVotes: PromiseOrValue<BigNumberish>,
      againstVotes: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    votingStrategy(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
